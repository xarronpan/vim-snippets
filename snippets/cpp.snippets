extends c

## Main
# main()
snippet mainn
	int main()
	{
		${0}
		return 0;
	}
##
## Preprocessor
# #include <...>
snippet incc "include cpp header"
	#include <${1:iostream}>
snippet binc "include boost header"
	#include <boost/${1:shared_ptr}.hpp>
##
## STL Collections
# std::array
snippet array "std::array"
	std::array<${1:T}, ${2:N}> ${3};
# std::vector
snippet vector "std::vector"
	std::vector<${1:T}> ${2};
# std::deque
snippet deque "std::deque"
	std::deque<${1:T}> ${2};
# std::forward_list
snippet flist "std::forward_list"
	std::forward_list<${1:T}> ${2};
# std::list
snippet list "std::list"
	std::list<${1:T}> ${2};
# std::set
snippet set "std::set"
	std::set<${1:T}> ${2};
# std::map
snippet map "std::map"
	std::map<${1:Key}, ${2:T}> ${3};
# std::multiset
snippet mset "std::multiset"
	std::multiset<${1:T}> ${2};
# std::multimap
snippet mmap "std::multimap"
	std::multimap<${1:Key}, ${2:T}> ${3};
# std::unordered_set
snippet uset ""std::unordered_set
	std::unordered_set<${1:T}> ${2};
# std::unordered_map
snippet umap "std::unordered_map"
	std::unordered_map<${1:Key}, ${2:T}> ${3};
# std::unordered_multiset
snippet umset "std::unordered_multiset"
	std::unordered_multiset<${1:T}> ${2};
# std::unordered_multimap
snippet ummap "std::unordered_multimap"
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};
# std::stack
snippet stack "std::stack"
	std::stack<${1:T}> ${2};
# std::queue
snippet queue "std::queue"
	std::queue<${1:T}> ${2};
# std::priority_queue
snippet pqueue "std::priority_queue"
	std::priority_queue<${1:T}> ${2};
##
## STL smart pointers
# std::shared_ptr
snippet sp "std::shared_ptr var"
	std::shared_ptr<${1:T}> ${2};
snippet msp "make std::shared_ptr var"
	std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
snippet amsp "make std::shared_ptr auto var"
	auto ${1} = std::make_shared<${2:T}>(${3});
# std::unique_ptr
snippet up "std::unique_ptr var"
	std::unique_ptr<${1:T}> ${2};
snippet mup "make std::unique_ptr var"
	std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});
snippet amup "make std::unique_ptr auto var"
	auto ${1} = std::make_unique<${2:T}>(${3});
##
## Access Modifiers
# private
snippet pri
	private
# protected
snippet pro
	protected
# public
snippet pub
	public
# friend
snippet fr
	friend
# mutable
snippet mu
	mutable
##
## Class
# class
snippet cls "class"
	class ${1:`vim_snippets#FilenameMixedCase('$1', 'name')`} {
	public:
		$1(${2});
		virtual ~$1();

	private:
		${3}_;
	};

snippet cpcon "copy constructor"
		${1:`vim_snippets#FilenameMixedCase('$1', 'name')`}(const $1& ${2:other});

snippet cpas "copy assignment"
		${1:`vim_snippets#FilenameMixedCase('$1', 'name')`}& operator=(const $1& ${2:other});

snippet mvcon "move constructor"
		${1:`vim_snippets#FilenameMixedCase('$1', 'name')`}($1&& ${2:other});

snippet mvas "move assignment"
		${1:`vim_snippets#FilenameMixedCase('$1', 'name')`}& operator=($1&& ${2:other});

# member function implementation
snippet mfun "member function/method implementation"
	${4:void} ${1:`vim_snippets#FilenameMixedCase('$1', 'ClassName')`}::${2:memberFunction}(${3}) {
		${0}
	}
# member function implementation without parameters
snippet dmfun0 "member function/method implementation without parameters"
	${3:void} ${1:`vim_snippets#FilenameMixedCase('$1', 'ClassName')`}::${2:memberFunction}() {
		${0}
	}
# member function implementation with one parameter
snippet dmfun1 "member function/method implementation with one parameter"
	${5:void} ${1:`vim_snippets#FilenameMixedCase('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter}) {
		${0}
	}
# member function implementation with two parameter
snippet dmfun2 "member function/method implementation with two parameter"
	${7:void} ${1:`vim_snippets#FilenameMixedCase('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter},${5:Type} ${6:Parameter}) {
		${0}
	}
# namespace
snippet ns "namespace"
	namespace ${1:`vim_snippets#Filename('', 'my')`} {
		${0}
	} /* namespace $1 */
snippet ans "anonymous name space"
	namespace {
		${0}
	}
##
## Input/Output
# std::cout
snippet cout
	std::cout << ${1} << std::endl;
# std::cin
snippet cin
	std::cin >> ${1};
##
## Casts
# static
snippet sca "static_cast"
	static_cast<${1:unsigned}>(${2:expr})${3}
# dynamic
snippet dca "dynamic_cast"
	dynamic_cast<${1:unsigned}>(${2:expr})${3}
# reinterpret
snippet rca "reinterpret_cast"
	reinterpret_cast<${1:unsigned}>(${2:expr})${3}
# const
snippet cca "const cast"
	const_cast<${1:unsigned}>(${2:expr})${3}
## Iteration
# for i
snippet fori "for i"
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}

# foreach
snippet fore "foreach"
	for (${1:auto} ${2:i} : ${3:container}) {
		${4}
	}
# iterator
snippet iter "iterator"
	for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
		${6}
	}

# auto iterator
snippet itera "auto iterator"
	for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
		${3:std::cout << *$1 << std::endl;}
	}
##
## Lambdas
# lambda (one line)
snippet ld "lambda (one line)"
	[${1}](${2}){${3}};
# lambda (multi-line)
snippet lld "lambda (multi-line)"
	[${1}](${2}){
		${3}
	};
# snippets exception
snippet try "try ... catch"
	try {

	}catch(${1}) {

	}
# auto function
snippet af auto function
	auto ${1:name}(${2}) -> ${3:void}
	{
		${0}
	};
# Range-v3 transform
snippet transform "ranges::views::transform"
	${1:${2:std::}${3:ranges::}views::}transform($4)
# Range-v3 transform
snippet filter "ranges::views::filter"
	${1:${2:std::}${3:ranges::}views::}filter($4)
# Range-v3 ranges::
snippet r "ranges::"
	ranges::
# Range-v3 ranges::views::
snippet rv "ranges::views::"
	ranges::views::
# Range-v3 ranges::actions::
snippet ra "ranges::actions::"
	ranges::actions::
# STL std::ranges::
snippet sr "std::ranges::"
	std::ranges::
# STL std::views::
snippet sv "std::views::"
	std::views::
